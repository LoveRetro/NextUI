#!/bin/sh
set -euo pipefail
exec 0<&-

wpa_running=
hciattach_running=
bluetoothd_running=

asound_state_dir=/tmp/asound-suspend

before() {
	>&2 echo "Preparing for suspend..."

    # The problem with the brick not being able to suspend seems to be something that has been tried to solved a few times before evidence by multiple code in the original MinUI firmware trying to tackle this problem in multiple ways
    # The problem is that sometimes it doesnt let you write to echo mem >/sys/power/state because its locked by something. 
    # The first solution tried to this is just implement a retry mechanism in platform.c that will try up to 3 times and if still failing do a complete shutdown
    # The second solution tried to this is to disable all hardware like wifi, audio etc before suspending trying to increase changes the state file is unlocked
    # A combination of both solutions seems to be enough to be able to suspend succesfully within the 3 retries. But disabling and enabling hardware causes other problems like wifi and audio not working correctly when resuming.
    # The real problem why state file is locked a lot of times is actually caused by that axp2202-battery seems to generate a lot of wakeup calls and it doesn't clear them the active wakeup count always keeps increasing. Causing the state file to be locked a lot increasing the chance for writing to state mem to fail by a lot

    # Below is my solution to this. I am actually able to make the axp2202 stop generating wakeup locks by sending disabled to each wakeup endpoint in the below sysf folder.
    # This def helps a lot keeping /sys/power/state unlocked a lot more. It doesn't mean it will never be locked as other things can lock it too. But hopefully the retry mechanism inside platform.c is enough to now always properly suspend
    # and disabling audio and wifi/bluetooth hardware is not needed anymore and we can have reliable wifi+audio on resume again. 

    max_retries=5
    retry_interval=1

    for f in $(find /sys/devices/platform/soc/7081400.s_twi/i2c-6/6-0034/ -name wakeup); do
            echo "Disabling wakeup in $f"
            echo disabled > "$f"
    done


    check_wakeup_sources() {
        awk '$1=="axp2202-usb" || $1=="axp2202-battery" { sum += $2 } END { if (sum == "") sum = 0; print sum }' /sys/kernel/debug/wakeup_sources
    }

    echo "Checking wakeup sources..."

    i=1
    while [ "$i" -le "$max_retries" ]; do
        count=$(check_wakeup_sources)

        # Ensure count is a number
        if echo "$count" | grep -qE '^[0-9]+$'; then
            if [ "$count" -eq 0 ]; then
            echo "All axp2202 wakeup sources inactive (active_count = 0). Safe to continue."
            break
            else
            echo "Attempt $i/$max_retries: active_count = $count, retrying in $retry_interval second(s)..."
            fi
        else
            echo "Attempt $i/$max_retries: Failed to read active_count (got '$count'), retrying..."
        fi

        sleep "$retry_interval"
        i=$((i + 1))
    done
    if [ "$i" -gt "$max_retries" ]; then
        echo "Timed out: wakeup sources still active or unreadable after $max_retries attempts."
        exit 1
    fi
    
    i=1
    while [ "$i" -le "$max_retries" ]; do
        if [ -w /sys/power/state ] && grep -qw mem /sys/power/state; then
            echo "Attempt $i: Suspending..."
            if echo mem > /sys/power/state 2>/dev/null; then
                echo "Suspend success"
                break
            else
                echo "Attempt $i: Suspend failed (device busy or other error), retrying in $retry_interval second(s)..."
            fi
        else
            echo "Check $i: 'mem' not supported or /sys/power/state not writable."
            exit 1
        fi

        sleep "$retry_interval"
        i=$((i + 1))
    done


    # Old suspend script stuff which seemed to help in suspending correctly, but aren't the real solution for the problem and cause other problems like wifi and audio sometimes not resuming correctly.
    # Real problem is explained at the top of this script which I'm trying to attempt to solve

	# >&2 echo "Saving mixer state..."
	# mkdir -p "$asound_state_dir"
	# alsactl --file "$asound_state_dir/asound.state.pre" store || true

	# if pgrep wpa_supplicant; then
	# 	wpa_running=1
	# 	>&2 echo "Stopping wpa_supplicant..."
	# 	killall -9 wpa_supplicant || true
	# fi
	# ifconfig wlan0 down || true

	# if pgrep hciattach; then
	# 	hciattach_running=1
	# 	>&2 echo "Stopping hciattach..."
	# 	/etc/init.d/hciattach stop || true
	# fi
	# if pgrep bluetoothd; then
	# 	bluetoothd_running=1
	# 	>&2 echo "Stopping bluetoothd..."
	# 	/etc/bluetooth/bluetoothd stop || true
	# 	killall -15 bluealsa || true
	# fi

	# >&2 echo "Blocking wireless..."
	# echo 0 >/sys/class/rfkill/rfkill0/state || true
}

after() {
	>&2 echo "Resumed from suspend."

    for f in $(find /sys/devices/platform/soc/7081400.s_twi/i2c-6/6-0034/ -name wakeup); do
        echo "Enabling wakeup in $f"
        echo enabled > "$f"
    done

    # Same old suspend script stuff

	# >&2 echo "Restoring mixer state..."
	# alsactl --file "$asound_state_dir/asound.state.post" store || true
	# alsactl --file "$asound_state_dir/asound.state.pre" restore || true

	# >&2 echo "Unblocking wireless..."
	# echo 1 >/sys/class/rfkill/rfkill0/state || true
    # ifconfig wlan0 up || true
	# if [ -n "$wpa_running" ]; then
	# 	>&2 echo "Starting wpa_supplicant..."
	# 	wpa_supplicant -B -iwlan0 -Dnl80211 -c/etc/wifi/wpa_supplicant.conf -I/etc/wifi/wpa_supplicant_overlay.conf -O/etc/wifi/sockets || true
	# 	(( udhcpc -i wlan0 &)&)
	# fi
    

	# if [ -n "$hciattach_running" ]; then
	# 	>&2 echo "Starting hciattach..."
	# 	/etc/init.d/hciattach start || true
	# fi
	# if [ -n "$bluetoothd_running" ]; then
	# 	>&2 echo "Starting bluetoothd..."
	# 	/etc/bluetooth/bluetoothd start || true
	# 	/usr/bin/bluetoothctl power on || true
	# fi
}

before

# Resume services in background to reduce UI latency
after
